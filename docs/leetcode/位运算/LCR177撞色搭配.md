#[LCR 177. 撞色搭配](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/description/?envType=study-plan-v2&envId=coding-interviews)

整数数组 sockets 记录了一个袜子礼盒的颜色分布情况，其中 sockets[i] 表示该袜子的颜色编号。礼盒中除了一款撞色搭配的袜子，每种颜色的袜子均有两只。请设计一个程序，在时间复杂度 O(n)，空间复杂度O(1) 内找到这双撞色搭配袜子的两个颜色编号。

**示例 1：**

```
输入：sockets = [4, 5, 2, 4, 6, 6]
输出：[2,5] 或 [5,2]
```

**示例 2：**

```
输入：sockets = [1, 2, 4, 1, 4, 3, 12, 3]
输出：[2,12] 或 [12,2]
```

**提示：**

- `2 <= sockets.length <= 10000`

## 思路
需要在时间复杂度为O(n)，并且空间复杂度为O(1)的限制内完成，那首先排除使用Set这一类空间复杂度为O(n)的思路。

需要在数组中挑选出两个没有重复的数字。那么，思路就可以转换删除在数组中重复的元素。
在**位操作**中，我们可以想到，两个数字的^(异或)操作（相同为0，相异为1。）
> 异或操作的特点：
> 
> 1. 自反性：任何数与其自身做异或运算结果都是0，即 A ⊕ A = 0。
> 2. 零特性：任何数与0做异或运算结果都是该数本身，即 A ⊕ 0 = A。

从上述异或操作的特性可以看到，如果我们将数组中的每一个数字进行异或，最终得到的结果便是**两个没有重复数字的异或结果**(也就是我们最终答案数字的异或结果)。

但此时，两个数字并不能够直接区分开来，我们只是拿到了这两个数字异或之后的结果。

**本题技巧点**：
拿到数组最终异或结果之后，我们寻找最终结果二进制序列中为1的位（异或结果为1，代表在这一位上进行异或的两个数字不同），然后根据这个特点
将数组中这一位都为1的数字进行异或操作。将这一位都为0的数字进行异或操作。得到的结果便是最终我们需要求得的数字。
> 根据为1的一位，将原来的数组分开，因为两个最终所求的数字在当前位上的值不同，所以一定会被划分到两个不同的数组中。

如何在第一次异或结果中找到为1的一位？ （我们可以选择找到从右往左数第一个为1的数字）

实现这个目的，我们可以使用[LowBit](leetcode/其他算法/lowbit.md)算法

## 代码

### java
```Java

class Solution {
    public int[] sockCollocation(int[] sockets) {
        int item = 0;
        for (int socket : sockets) {
            item = item ^ socket;
        }
        int[] res = new int[2];
        // 找到最低位的1
        int lowBit = item & (-item);
        int res1 = 0, res2 = 0;
        for (int socket : sockets) {
            if((socket & lowBit) == 0){
                res1 ^= socket; 
            }else{
                res2 ^= socket;
            }
        }
        res[0] = res1;
        res[1] = res2;
        return res;
    }
}

```


