# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

 [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)



给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。



**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

+ `1 <= s.length, t.length <= 105`
+ `s` 和 `t` 由英文字母组成



## 思路

这道题求的是一个区间，这个区间有两个特点，第一个特点是包含指定的字符；第二个特点是最短；

一般求区间问题，并且这个区间是总区间的一个子区间的问题都是使用滑动窗口。

在窗口滑动的过程中我们需要判断窗口内的字符是否包含了`t`字符串中的所有字符。完成这个目的我们可以采用map来存储每个字符的个数；

同时使用一个map来存储当前滑动窗口中的元素，那我们在滑动窗口向右移动的过程中，添加进入滑动窗口的元素并删除掉出窗口的元素，同时判断当前窗口内的元素是否满足包含t中所有字符的要求，如果满足要求，那么我们就持续向后移动指针，删除掉最左边的元素(让左边元素出窗口)。一直到窗口内的元素不满足第一个特点。滑动窗口每出去一个元素就记录当前长度的字符串是否是当前最短的，如果是的话就将当前字符串赋值为当前最优结果。



## 代码

### Golang

```go
func minWindow(s string, t string) string {
    // 初始化两个map用来存储t中的字符和窗口中的字符
    need,window := map[byte]int{},map[byte]int{}
    
    // 将t字符串中的字符添加到need中，后续对比需要用到
    for i:=0;i<len(t);i++{
        need[t[i]]++
    }

    // 初始化两个指针 分别代表滑动窗口的两端
    left,right:=0,0
    // 记录当前满足要求的字符个数，直接比较valid和t中不同字符的个数就可以得到当前窗口中元素是否满足要求
    // 具体比较方法是： 每当窗口中的元素个数和t中相同元素个数相等时valid就加一
    valid := 0
    // 记录最终字符串起始位置
    start := 0
    // 记录满足要求字符串长度
    sLen := math.MaxInt64
    //滑动窗口遍历s字符串
    for right < len(s){
        item := s[right]
        right++
        //如果当前元素出现在need中，也就是当前字符是t字符串当中的一个字符
        //因为窗口中的元素只需要比较t中有的元素，因此不需要将不出现在t中的字符加入窗口中
        if _,ok:=need[item];ok{
            //将当前元素统计到窗口中
            window[item]++
            // 如果窗口内指定元素的格式和t中相同元素 valid就加一 表示已经有一个元素达到了数量要求
            if window[item] == need[item]{
                valid++
            }
        }
        // 如果达到数量要求的元素和t中不同元素数量相同就表示当前窗口中元素已经包含t中所有元素，现在开始缩小窗口
        for valid == len(need){
            if right - left < sLen{
                start = left
                sLen = right - left
            }
            
            out := s[left]
            left++
            //元素出窗口，如果当前出窗口元素在t中(在t中的才会被存储，不在的直接过掉就可以了 因为一开始就没存)
            if  _,ok:=need[out];ok{
                // 如果出窗口元素和t中相同元素个数相等 那么当前元素出窗口之后就不满足情况了 所以valid要减一
                if window[out] == need[out]{
                    valid--
                }
                window[out]--
            }
        }
    }
    if sLen == math.MaxInt64{
        return ""
    }
    return s[start:start+sLen]
}
```

