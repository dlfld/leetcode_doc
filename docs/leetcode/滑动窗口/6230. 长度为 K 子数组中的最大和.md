#  长度为 K 子数组中的最大和

 [6230. 长度为 K 子数组中的最大和](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/)



给你一个整数数组 `nums` 和一个整数 `k` 。请你从 `nums` 中满足下述条件的全部子数组中找出最大子数组和：

- 子数组的长度是 `k`，且
- 子数组中的所有元素 **各不相同 。**

返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 `0` 。

**子数组** 是数组中一段连续非空的元素序列。

**示例 1：**

```
输入：nums = [1,5,4,2,9,9,9], k = 3
输出：15
解释：nums 中长度为 3 的子数组是：
- [1,5,4] 满足全部条件，和为 10 。
- [5,4,2] 满足全部条件，和为 11 。
- [4,2,9] 满足全部条件，和为 15 。
- [2,9,9] 不满足全部条件，因为元素 9 出现重复。
- [9,9,9] 不满足全部条件，因为元素 9 出现重复。
因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。
```

**示例 2：**

```
输入：nums = [4,4,4], k = 3
输出：0
解释：nums 中长度为 3 的子数组是：
- [4,4,4] 不满足全部条件，因为元素 4 出现重复。
因为不存在满足全部条件的子数组，所以返回 0 。
```

**提示：**

 `1 <= k <= nums.length <= 105`

- `1 <= nums[i] <= 105`



## 思路

这个题一看到能想到两种解法，第一种是暴力，第二种是滑动窗口；

滑动窗口的典型应用，这个题就是一个长度为k的区间一直在向右滑动，并且答案是在这个滑动的区间内的，因此满足滑动窗口的阶梯特点，所以我们考虑使用滑动窗口。

暴力在这道题中会超时，但是解法中能够用暴力求解。

**滑动窗口**

我们维护一个长度为k的区间，并且维护一个这个区间所有元素的和，然后让这个区间一直向右移动，在移动过程中移出的元素（区间左边的元素）会在sum中减掉它，移入的元素会在sum中加上它，然后计算这个区间的和是否是当前最大值。

在这道题当中，题干还加入了另外的一层条件：区间内元素不能够有重复值。因此，我们在窗口滑动的时候只需要维护一个map来记录当前元素是否已经在窗口中吗，如果当前元素在窗口中，则将滑动窗口的起点移动到当前元素第一次出现的位置的后一个位置上，并将沿途的元素用sum减掉，从map中移除出去；具体操作如下：

+ 初始化两个指针，两个指针均指向0
+ 初始化一个map用来保存当前滑动窗口当中的元素
+ right指针一直向前移动，直到right指针到达数组的最后一个位置
	+ 将right指针指向的元素值加和sum求和并赋值给sum
	+ 判断当前滑动窗口区间中是否有当前值（通过map判断，map的下标记录元素所在的位置）
		+ 如果滑动窗口中有当前值
			+ left指针从当前位置一直走到right所指元素第一次出现的位置（包括第一次出现的位置）
			+ 在map中删除left经过的每一个元素
			+ 在sum中删除left经过的每一个元素
		+ 将right指向的值添加到map中
		+ 判断当前left到right的滑动区间是否大于k
			+ 如果大于sum就减去left的值
			+ left前进一位
		+ 判断left right是否相距k，并且当前sum是否是当前最大



## 代码

### golang

```go
func maximumSubarraySum(nums []int, k int) int64 {
	var res int64 = 0
	cache := map[int]int{}
	left,right := 0,0
	var sum int64 = 0
	for ;right < len(nums);right++{
        // sum 加上当前元素
		sum+=int64(nums[right])
        // 如果当前元素已经在map中出现过，表示当前元素已经在滑动窗口中出现过
		if loc,ok:=cache[nums[right]];ok{
            // left移动到当前元素第一次出现位置的后一个位置并删除掉中间的元素
			for ;left<=loc;left++{
				sum-=int64(nums[left])
                delete(cache, nums[left])
			}
		}
        // 将当前元素放入滑动窗口
        cache[nums[right]] = right
        // 如果长度大于k了那就删除掉最左边的元素，让窗口保持k的长度
        if right - left + 1 > k{
            sum-=int64(nums[left])
            left++
        }
		if right-left+1 == k && sum > res{
			res = sum
		}
	}
	return res
}
```

