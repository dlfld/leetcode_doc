# 线段树
存放区间数据的二叉树，称之为线段树，线段树只需要用小区间的值来更新大区间，线段树是**平衡二叉树**，因此线段树的时间复杂度总是log级别的。线段树母结点代表整个区间的和，越往下区间越小。注意，线段树的每个节点都对应一条线段（区间），但并不保证所有的线段（区间）都是线段树的节点，这两者应当区分开。

**线段树局限性**：必须要满足区间加法
区间问题：对于[L,R]的区间，它的答案可以由[L,M]和[M+1,R]的答案合并求出 

满足的问题；：区间求和，区间最大值和最小值等；

不满足的问题：区间的众数，区间最长连续问题，最长不下降问题等

线段树解决问题的步骤：

+ 建树
+ 单点修改/区间修改  （在区间修改中会用到<lazy标记>）
+ 区间查询
    
## 建树
使用数组或者链表来存储数据，如果使用数组来存储的话，假设某一节点的下标为i，则其父节点的下标为i/2，其左子节点的下标为2i,右子节点的下标为2i+1.线段树的长度一般需要开到4n才会确保不会越界访问。以堆的方式存储数据

## 单点修改
仅有单点修改的区间查询不需要处理lazy标记。

搜索到需要修改的值并进行修改，使用DFS搜索到需要修改的值，进行修改后回溯。

## 求区间和
求区间和可以分为大致的分为三步：1.覆盖；2.合并；3.左/右

具体步骤：

如果查询的区间完全覆盖当前区间，则直接返回当前区间的值

如果查询区间和左儿子有交集，则搜索左儿子

如果查询区间和右儿子有交集，则搜索右儿子

最后合并处理两边查询的数据


## 区间修改
如果按照常规思路向下递归遍历所有节点一一修改，其时间复杂度和暴力处理相差无几。
<lazy>标记，将此区间标记，表示这个区间的值已经更新，但它的子区间的值却没有更新，更新的信息就是标记里存的值

更新步骤

如果要修改的区间完全覆盖当前区间；直接更新这个区间，打上lazy标记

如果没有完全覆盖，且当前区间有lazy标记；先下传lazy标记到 子区间，再清除当前区间的lazy标记。

如果修改区间和左儿子有交集  搜索左儿子

如果修改区间和右儿子有交集  搜索右儿子

最后将区间的值更新


可以简化为四个步骤：

覆盖 左/右 下传清除 更新