# LowBit

## 应用场景

​	在一些算法中，我们需要获取一个数的每一位的二进制，比如说<code>10100</code>,我们要获取到`100`、`10000`这两个二进制数,那么立即能够想到的是一个比较笨的方法——将这个数转化为二进制字符串，然后直接对二进制字符串进行遍历便可得到相应的结果。

​	比较好一点的方法我们可以想到 

​					`n  = 10100`

​					`~n = 01011`     这一步是按位取反

​					`~n+1=01100 `    在按位取反之后的数上+1

实际上在二进制里面按位取反再加一之后的结果就是这个数的相反数；因此 `~n+1 == -n`,此时，我们再使用`n`和`-n`相与便可以得到第一个低位的`100`,此时我们再使用异或操作删除掉低位的1，之后再继续上述操作便可以实现每一个最低位的1；



因此`lowbit = n & -n`



leetcode类似题链接[[2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/)](https://leetcode.cn/problems/range-product-queries-of-powers/)

这道题第一步的powers数组便可以用这种方式求解

