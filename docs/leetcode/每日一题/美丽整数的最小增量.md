# 美丽整数的最小增量

[美丽整数的最小增量](https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/)



给你两个正整数 `n` 和 `target` 。

如果某个整数每一位上的数字相加小于或等于 `target` ，则认为这个整数是一个 **美丽整数** 。

找出并返回满足 `n + x` 是 **美丽整数** 的最小非负整数 `x` 。生成的输入保证总可以使 `n` 变成一个美丽整数。

**示例 1：**

```
输入：n = 16, target = 6
输出：4
解释：最初，n 是 16 ，且其每一位数字的和是 1 + 6 = 7 。在加 4 之后，n 变为 20 且每一位数字的和变成 2 + 0 = 2 。可以证明无法加上一个小于 4 的非负整数使 n 变成一个美丽整数。
```

**示例 2：**

```
输入：n = 467, target = 6
输出：33
解释：最初，n 是 467 ，且其每一位数字的和是 4 + 6 + 7 = 17 。在加 33 之后，n 变为 500 且每一位数字的和变成 5 + 0 + 0 = 5 。可以证明无法加上一个小于 33 的非负整数使 n 变成一个美丽整数。
```



**示例 3：**

```
输入：n = 1, target = 1
输出：0
解释：最初，n 是 1 ，且其每一位数字的和是 1 ，已经小于等于 target 。
```

**提示：**

+  `1 <= n <= 1012`
+ `1 <= target <= 150`
+ 生成的输入保证总可以使 `n` 变成一个美丽整数。





## 思路

首先，遇到这种题首先我想到的是暴力，直接一个一个加起来，将X从0一直加到能够表示为止，很显然，这种方式时间复杂度超了限制。

后面为了简化时间复杂度，才有了以下思路：

首先，我们将所给数字n的每一位数字进行求和，看其和是否小于`target`如果小于等于则直接返回。

如果大于`target`那我们可以有以下的思考过程，我们需要在`n`的某一些位上加一定的数字让其进位，进位之后就可以将当前数字位上的数字变为0，如果当前位置还有更高的数位，那么更高的数位就会+1（因为低位进1）。如果没有更高位，那么就创造最高位并赋值为1，在整个过程中，我们如果在让高位进1肯定会比让低位进1所加的数大，因此我们便可以从低位开始一个位置一个位置的进1，看看在哪一位的时候进1之后能够满足题目要求，此时累加所有为了进位而添加的数字便是最后我们得到的答案。



## 代码

### Golang

```go
func makeIntegerBeautiful(n int64, target int) int64 {
    var x int64 = 0
    
    nums,sum := getN(n)
    k := 0
    for i:=0;i<len(nums);i++{
        if sum > int64(target) {
            if nums[i] != 0{
               sum -= nums[i]
                x += int64((10-nums[i]) * int64(geta(k)))
                if i+1 < len(nums){
                    nums[i+1] += 1
                    sum++
                } 
            }
            k++
            
            continue
        }
       break
    }
    return x
}
func geta(k int)int{
    res := 1
    for i:=0;i<k;i++{
        res*=10
    }
    return res
}
func getN(a int64)([]int64,int64){
    res :=[]int64{}
    var sum int64 = 0
    for a > 0{
        res = append(res,a % 10)
        sum += a % 10
        a = a/10
    }
    return res,sum
}
```

