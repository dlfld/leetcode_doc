# 达到末尾下标所需的最大跳跃次数

[\6899. 达到末尾下标所需的最大跳跃次数](https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/description/)

给你一个下标从 **0** 开始、由 `n` 个整数组成的数组 `nums` 和一个整数 `target` 。

你的初始位置在下标 `0` 。在一步操作中，你可以从下标 `i` 跳跃到任意满足下述条件的下标 `j` ：

- `0 <= i < j < n`
- `-target <= nums[j] - nums[i] <= target`

返回到达下标 `n - 1` 处所需的 **最大跳跃次数** 。

如果无法到达下标 `n - 1` ，返回 `-1` 。

**示例 1：**

```
输入：nums = [1,3,6,4,1,2], target = 2
输出：3
解释：要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作：
- 从下标 0 跳跃到下标 1 。 
- 从下标 1 跳跃到下标 3 。 
- 从下标 3 跳跃到下标 5 。 
可以证明，从 0 到 n - 1 的所有方案中，不存在比 3 步更长的跳跃序列。因此，答案是 3 。 
```

**示例 2：**

```
输入：nums = [1,3,6,4,1,2], target = 3
输出：5
解释：要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作：
- 从下标 0 跳跃到下标 1 。 
- 从下标 1 跳跃到下标 2 。 
- 从下标 2 跳跃到下标 3 。 
- 从下标 3 跳跃到下标 4 。 
- 从下标 4 跳跃到下标 5 。 
可以证明，从 0 到 n - 1 的所有方案中，不存在比 5 步更长的跳跃序列。因此，答案是 5 。 
```

**示例 3：**

```
输入：nums = [1,3,6,4,1,2], target = 0
输出：-1
解释：可以证明不存在从 0 到 n - 1 的跳跃序列。因此，答案是 -1 。 
```

**提示：**

- `2 <= nums.length == n <= 1000`
- `0 <= target <= 2 * 109`
- `-109 <= nums[i] <= 109`

## 思路

从第一个位置根据一定的条件选出下一个位置跳过去，一直跳到最后一个位置；如果是没有条件的往后跳，要获取最多的步骤，那么结果就是一个一个的往后跳。现在加了条件之后，那么我们可以有两种方式来解决这个问题

1. 回溯（记忆化递归）：我们可以一直往后遍历，选择当前满足条件的节点是否作为下一跳的节点，并以此进行回溯。直到跳到最后一个节点处，我们再比较所走的步数，并找到最长的步数为止。[回溯版本](../回溯/达到末尾下标所需的最大跳跃次数.md)

2. 动态规划。

	根据动态规划的定义，我们可以将dp数组定义为一个一维数组，`dp[i]`定义为从0位置跳到i位置需要的最长步骤。

	同时，令`dp[0] = 0`,因为我们一开始是站在这个位置上的。其他的位置为-1，因为还没有访问过。

​		然后遍历每一个位置，计算前面的每一个位置，到当前位置最大的步骤数；

## 代码

### Golang

```go
func maximumJumps(nums []int, target int) int {
		dp := make([]int,len(nums))
		dp[0] = 0
		for i := 1; i < len(nums); i++{
			dp[i] = -1
		}
		for i := 1; i < len(nums); i++{
			 for j := 0; j < i; j++{
				 if abs(nums[i] - nums[j]) <= target && dp[j] != -1{
						dp[i] = max(dp[i],dp[j] + 1)
				 }
				 
			 }
		}
		return dp[len(nums) - 1]
}
func max(a,b int)int{
	if a > b{
		return a
	}
	return b
}
func abs(a int)int{
	if a > 0{
		return a
	}
	return -a
}
```

