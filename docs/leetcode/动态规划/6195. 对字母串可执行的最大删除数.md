# 6195. 对字母串可执行的最大删除数
[6195. 对字母串可执行的最大删除数](https://leetcode.cn/problems/maximum-deletions-on-a-string/)


给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以：

删除 整个字符串 s ，或者
对于满足 1 <= i <= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。
例如，如果 s = "ababc" ，那么在一步操作中，你可以删除 s 的前两个字母得到 "abc" ，因为 s 的前两个字母和接下来的两个字母都等于 "ab" 。

返回删除 s 所需的最大操作数。


**示例 1：**
```
输入：s = "abcabcdabc"
输出：2
解释：
- 删除前 3 个字母（"abc"），因为它们和接下来 3 个字母相等。现在，s = "abcdabc"。
- 删除全部字母。
一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。
注意，在第二步操作中无法再次删除 "abc" ，因为 "abc" 的下一次出现并不是位于接下来的 3 个字母。
```

**示例 2：**
```
输入：s = "aaabaab"
输出：4
解释：
- 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "aabaab"。
- 删除前 3 个字母（"aab"），因为它们和接下来 3 个字母相等。现在，s = "aab"。 
- 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "ab"。
- 删除全部字母。
一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。
```

**示例 3：**
```
输入：s = "aaaaa"
输出：5
解释：在每一步操作中，都可以仅删除 s 的第一个字母。
```

**提示：**
+ 1 <= s.length <= 4000
+ s 仅由小写英文字母组成

## 思路
根据题意，每次操作结束后，剩下的还是一个子串（一个完整的字符串）。我们对当前操作计数后，对剩下的字符串做同样的处理。因此是对子问题进行处理。
又可以对子串进行同样的操作 => 子问题 => DP。 因此推出使用DP来解
dp[i] = 操作从s[i:](从s[i]开始的 所需要的最大操作次数)如果s[i:i+j] == s[i+j:i+2*j] 这个表示的是第i个数，往后走j位，这一段路程中是否满足前i个和后i个相同

因此我们只需要比较当前i开始到字符串结束所花费的步数最多的一次作为当前从i开始的子字符串的解，从后往前一直推到第一项就行。

## 代码
```golang
func deleteString(s string) int {
    n := len(s)
    dp := make([]int,n)
    max := 0
    for i:=n-1;i>=0;i--{
        dp[i] = 1
        for j:=i+1;j+j-i<=len(s);j++{
            if s[i:j] == s[j:j+j-i]{
                dp[i] = getMax(dp[i],dp[j]+1)
                if dp[i] > max{
                    max = dp[i]
                }
            }
        }
    }
    return dp[0]
}

func getMax(a ,b int)int{
    if a > b{
        return a
    }
    return b
}

```
