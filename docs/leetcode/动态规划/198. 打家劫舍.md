# [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)



你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。



**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`



## 思路

根据题意我们知道，这些房子当中，相邻的房子不能被盗窃，那么我们就不能够一次性盗窃所有的房子，只能够**选择**一些进行盗窃。因此，每一间房子的**状态**就有两种，第一种是房子没有被盗窃，第二种是房子被盗窃了。由此我们可以联想到动态规划来解决这个问题，使用动态规划来根据状态选择一些最优结果。

​	

**DP二维数组**



使用动态规划可以有两种不同的实现方式，不过基本上就是一种思路 -> 这个房子到底偷不偷



根据上面的分析我们可以得出房子有两种状态，因此我们初始化一个二维数组，二维数组的每一行代表一个房子，每一列代表当前房子的一个状态；

一个房子有两个状态，因此我们使用`dp[i][0]`表示当前房子不偷，使用`dp[i][1]`表示偷当前房子，因此，我们可以得到下面的状态转移公式

`dp[i][0] = max(dp[i-1][0],dp[i-1][1])`这个表示当前的房子不偷的状态可以由两个状态转移而来：

+ 上一个房子不偷
+ 上一个房子偷

然后看这两个状态哪一个得到的钱最多

`dp[i][1] = max(dp[i-1][0],dp[i-2][1])+nums[i]`这个表示当前的房子偷的状态可以由两个状态转移而来

+ 上一个房子能偷不偷，因此这个房子是可以偷的
+ 上个房子不能偷不偷，那么上上个房子一定是偷了，偷了会比不偷多因此需要往前看两步



## 代码

### golang

**二维数组版本**

```go
func rob(nums []int) int {
    if len(nums) == 2{
        return max(nums[0],nums[1])
    }
    dp := make([][]int,len(nums))
    for i:=0;i<len(dp);i++{
        dp[i] = make([]int,2)
    }
    dp[0][0] = 0
    dp[0][1] = nums[0]
    for i:=1;i<len(nums);i++{
        if i - 2 < 0{
            dp[i][0] = dp[i-1][0]
            dp[i][1] = max(dp[i-1][1],nums[i])
            continue
        }
        dp[i][0] = max(dp[i-1][0],dp[i-1][1])
        dp[i][1] = max(dp[i-1][0],dp[i-2][1])+nums[i]
    } 
    return max(dp[len(nums)-1][0],dp[len(nums)-1][1])
}

func max(a,b int)int{
    if a > b{
        return a
    }
    return b
}
```



**一维数组版本**

```go
func rob(nums []int) int {
    if len(nums) == 0{
        return 0
    }
    if len(nums) == 1{
        return nums[0]
    }
    dp := make([]int,len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0],nums[1])
    
    for i:=2;i< len(dp);i++{
        dp[i] = max(dp[i-2]+nums[i],dp[i-1])
    }
    return dp[len(nums)-1]
}
func max(a,b int) int{
    if a>b{
        return a
    }
    return b
}
```

